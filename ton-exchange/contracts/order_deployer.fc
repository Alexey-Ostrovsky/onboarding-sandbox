#include "imports/constants.fc";
#include "imports/stdlib.fc";
#include "imports/order-utils.fc";
#include "imports/order-asserts.fc";
#include "imports/opcodes.fc";
#include "imports/out-log.fc";
#include "imports/utils.fc";

(slice, int, cell, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(), ;; admin_address
        ds~load_uint(32), ;; current order_id
        ds~load_ref(), ;; order_code
        ds~load_ref()       ;; jetton_wallet_code
    );
}

() save_data(slice admin_address, int order_id, cell order_code, cell jetton_wallet_code) impure {
    set_data(begin_cell()
        .store_slice(admin_address)
        .store_uint(order_id, 32)
        .store_ref(order_code)
        .store_ref(jetton_wallet_code)
        .end_cell()
    );
}

() create_order(slice in_msg_body, slice sender_address, int msg_value, int fwd_fee, int my_ton_balance) impure {
    int query_id = in_msg_body~load_uint(64);
    int jetton_amount = in_msg_body~load_coins();
    slice from_address = in_msg_body~load_msg_addr(); ;; jetton's owner address - order creator

    slice either_forward_payload = in_msg_body;
    throw_if_fill_order_payload_invalid(714, either_forward_payload);

    var (owner_address, order_id, order_code, jetton_wallet_code) = load_data();

    slice payload = either_forward_payload; ;; copy for extracting
    slice base_jetton_slice = payload~load_ref().begin_parse();
    slice base_jetton_address = base_jetton_slice~load_msg_addr();
    slice quote_jetton_address = base_jetton_slice~load_msg_addr();
    int side = payload~load_uint(1);
    int price = payload~load_uint(32);

    ;; instead of order create jetton wallet address we use order deployer
    ;; jetton wallet address because it will be the same currency
    throw_if_jetton_wallet_fraud_detected(sender_address, side == side::SELLER ? base_jetton_address : quote_jetton_address, jetton_wallet_code);
    throw_unless(715, side == side::SELLER & (jetton_amount ^% price == 0));

    ;; reserve tons for storage and current computations
    int ton_balance_before_msg = my_ton_balance - msg_value;
    int storage_fee = tons_for_storage() - min(ton_balance_before_msg, tons_for_storage());
    msg_value -= (storage_fee + consumption());

    cell state_init = calculate_order_state_init(my_address(), order_id, order_code, jetton_wallet_code);
    slice new_order_address = calculate_order_address(state_init);

    throw_unless(900, msg_value > 4 * (fwd_fee + consumption()));

    ;; reserve tons for deploy
    msg_value -= (fwd_fee + consumption());

    ;; notify about new order
    builder log = begin_cell()
        .store_uint(order_id, 32)
        .store_slice(new_order_address)
        .store_slice(from_address);
    send_log(log);

    ;; deploy new order contract
    var msg_body = begin_cell()
        .store_uint(op::init_order(), 32)
        .store_uint(query_id, 64)
        .store_slice(from_address)
        .end_cell();
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(new_order_address)
        .store_coins(fwd_fee + consumption())
        .store_uint(0, 1 + 4 + 4 + 64 + 32)
        .store_uint(1, 1)
        .store_uint(1, 1)
        .store_ref(state_init)
        .store_uint(1, 1)
        .store_ref(msg_body);
    send_raw_message(msg.end_cell(), 2);

    ;; reserve forward fee
    int forward_ton_amount = fwd_fee + consumption();
    msg_value -= forward_ton_amount;

    ;; send jetton to orders wallet
    var order_wallet_msg_body = begin_cell()
        .store_uint(op::transfer(), 32)
        .store_uint(query_id, 64)
        .store_coins(jetton_amount)
        .store_slice(new_order_address)
        .store_slice(from_address)     ;; response_address for excesses
        .store_uint(0, 1)              ;; empty custom payload (either dict)
        .store_coins(forward_ton_amount)
        .store_slice(either_forward_payload);

    var order_wallet_msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(sender_address) ;; deployer's jetton wallet address
        .store_coins(msg_value)
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(order_wallet_msg_body.end_cell());
    send_raw_message(order_wallet_msg.end_cell(), 0);

    save_data(owner_address, order_id + 1, order_code, jetton_wallet_code);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    cs~load_msg_addr();                           ;; skip dst
    cs~load_coins();                              ;; skip value
    cs~skip_bits(1);                              ;; skip extracurrency collection
    cs~load_coins();                              ;; skip ihr_fee
    int fwd_fee = muldiv(cs~load_coins(), 3, 2);  ;; we use message fwd_fee for estimation of forward_payload costs

    int op = in_msg_body~load_uint(32);

    if (op == op::transfer_notification()) {
        create_order(in_msg_body, sender_address, msg_value, fwd_fee, my_balance);
        return ();
    }

    throw(0xffff);
}

(slice, int, cell, cell) get_order_deployer_data() method_id {
    var (admin_address, order_id, order_code, jetton_wallet_code) = load_data();
    return (admin_address, order_id, order_code, jetton_wallet_code);
}

slice get_order_address(int order_id) method_id {
    (_, _, cell order_code, cell jetton_wallet_code) = load_data();
    cell state_init = calculate_order_state_init(my_address(), order_id, order_code, jetton_wallet_code);
    return calculate_order_address(state_init);
}
